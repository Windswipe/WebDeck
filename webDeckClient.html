<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stream Deck</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #000000 0%, #000000 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            width: 100%;
        }

        .connection-banner {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 6px;
            font-size: 0.9em;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .connection-banner.connected {
            background: rgba(74, 222, 128, 0.2);
            border: 1px solid #4ade80;
            color: #4ade80;
        }

        .connection-banner.disconnected {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid #ef4444;
            color: #ef4444;
        }

        .connection-banner.scanning {
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid #3b82f6;
            color: #3b82f6;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .connection-banner.connected .status-dot {
            background: #4ade80;
            animation: none;
        }

        .connection-banner.disconnected .status-dot {
            background: #ef4444;
            animation: pulse 1s infinite;
        }

        .connection-banner.scanning .status-dot {
            background: #3b82f6;
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .connection-details {
            font-size: 0.8em;
            opacity: 0.8;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            color: white;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
            letter-spacing: 2px;
        }

        .header p {
            color: #aaa;
            font-size: 0.95em;
        }

        .deck {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 12px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        .deck.disabled {
            opacity: 0.4;
            pointer-events: none;
        }

        .button {
            aspect-ratio: 1 / 1;
            background: linear-gradient(135deg, #0f3460 0%, #16213e 100%);
            border: 2px solid #3700ff;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            color: white;
            font-weight: 600;
            font-size: 0.85em;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(233, 69, 96, 0.2);
        }

        .button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: rgba(233, 69, 96, 0.1);
            transition: left 0.3s ease;
        }

        .button:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 25px rgba(233, 69, 96, 0.4);
            border-color: #00eeff;
        }

        .button:hover::before {
            left: 100%;
        }

        .button:active {
            transform: translateY(-2px) scale(0.98);
        }

        .button-label {
            position: relative;
            z-index: 1;
            text-align: center;
            padding: 10px;
            font-size: 0.75em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .button-icon {
            position: relative;
            z-index: 1;
            font-size: 1.8em;
            margin-bottom: 5px;
        }

        .status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #4ade80;
            border-radius: 6px;
            font-size: 0.9em;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .status.active {
            opacity: 1;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            align-items: center;
            justify-content: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: rgba(20, 20, 30, 0.95);
            border: 1px solid #3700ff;
            border-radius: 12px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
        }

        .modal-content h2 {
            color: white;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .modal-content p {
            color: #aaa;
            margin-bottom: 20px;
            font-size: 0.95em;
            line-height: 1.5;
        }

        .modal-input-group {
            margin-bottom: 20px;
        }

        .modal-input-group label {
            display: block;
            color: #aaa;
            font-size: 0.9em;
            margin-bottom: 8px;
        }

        .modal-input-group input {
            width: 100%;
            padding: 10px;
            border: 2px solid #3700ff;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 1em;
            box-sizing: border-box;
            transition: border-color 0.3s ease;
        }

        .modal-input-group input:focus {
            outline: none;
            border-color: #00eeff;
        }

        .modal-input-group input::placeholder {
            color: #666;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .modal-btn {
            padding: 10px 20px;
            border: 2px solid #3700ff;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }

        .modal-btn:hover {
            background: #3700ff;
            border-color: #00eeff;
        }

        .modal-btn.primary {
            background: #3700ff;
            border-color: #3700ff;
        }

        .modal-btn.primary:hover {
            background: #5500ff;
        }

        @media (max-width: 600px) {
            .deck {
                grid-template-columns: repeat(4, 1fr);
                gap: 10px;
                padding: 15px;
            }

            .header h1 {
                font-size: 2em;
            }

            .connection-banner {
                top: 10px;
                right: 10px;
                font-size: 0.8em;
            }
        }
    </style>
</head>
<body>
    <div class="connection-banner" id="connectionBanner">
        <div class="status-dot"></div>
        <div>
            <div>Scanning...</div>
            <div class="connection-details" id="connectionDetails"></div>
        </div>
    </div>

    <div class="modal" id="connectionModal">
        <div class="modal-content">
            <h2>Server Not Found</h2>
            <p>Could not find the WebDeck server. Please enter the IP address or start a network scan.</p>
            <div class="modal-input-group">
                <label for="serverIP">Server IP Address (optional)</label>
                <input type="text" id="serverIP" placeholder="e.g., 192.168.1.100" />
            </div>
            <div class="modal-buttons">
                <button class="modal-btn" id="scanBtn">Scan Network</button>
                <button class="modal-btn primary" id="connectBtn">Connect</button>
            </div>
        </div>
    </div>

    <div class="modal" id="securityWarningModal">
        <div class="modal-content">
            <h2>⚠️ Security Warning</h2>
            <p>Network scanning may trigger security alerts on your device or router. Some antivirus software and firewalls may flag IP scanning as suspicious activity and could temporarily block or throttle the scan.</p>
            <p><strong>Recommendation:</strong> If you know your server's IP address, use the manual entry method instead of scanning.</p>
            <div class="modal-buttons">
                <button class="modal-btn" id="cancelScanBtn">Cancel</button>
                <button class="modal-btn primary" id="confirmScanBtn">Continue Scanning</button>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <h1>WebDeck Client</h1>
        </div>

        <div class="deck disabled" id="deck"></div>
    </div>

    <div class="status" id="status"></div>

    <script>
        let serverAddress = null;
        let buttons = [];
        let refreshInterval = null;
        const statusElement = document.getElementById('status');
        const deckElement = document.getElementById('deck');
        const bannerElement = document.getElementById('connectionBanner');
        const detailsElement = document.getElementById('connectionDetails');

        // Cookie management functions
        function setCookie(name, value, days = 30) {
            const date = new Date();
            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
            const expires = `expires=${date.toUTCString()}`;
            document.cookie = `${name}=${value};${expires};path=/`;
        }

        function getCookie(name) {
            const nameEQ = `${name}=`;
            const cookies = document.cookie.split(';');
            for (let cookie of cookies) {
                cookie = cookie.trim();
                if (cookie.indexOf(nameEQ) === 0) {
                    return cookie.substring(nameEQ.length);
                }
            }
            return null;
        }

        // Fetch button configuration from server
        async function fetchButtonConfiguration() {
            if (!serverAddress) return false;
            
            try {
                const response = await fetch(`${serverAddress}/buttons`, {
                    method: 'GET',
                    signal: AbortSignal.timeout(5000)
                });
                
                if (response.ok) {
                    const newButtons = await response.json();
                    // Only re-render if buttons have changed
                    if (JSON.stringify(buttons) !== JSON.stringify(newButtons)) {
                        buttons = newButtons;
                        renderButtons();
                    }
                    return true;
                }
            } catch (error) {
                console.error('Failed to fetch button configuration:', error);
            }
            return false;
        }

        // Start periodic button refresh
        function startButtonRefresh(interval = 10000) {
            // Clear existing interval if any
            if (refreshInterval) clearInterval(refreshInterval);
            
            // Refresh immediately
            fetchButtonConfiguration();
            
            // Then refresh periodically
            refreshInterval = setInterval(() => {
                fetchButtonConfiguration();
            }, interval);
        }

        // Stop periodic button refresh
        function stopButtonRefresh() {
            if (refreshInterval) {
                clearInterval(refreshInterval);
                refreshInterval = null;
            }
        }

        // Render buttons
        function renderButtons() {
            deckElement.innerHTML = '';
            buttons.forEach(btn => {
                const button = document.createElement('button');
                button.className = 'button';
                button.innerHTML = `
                    <div class="button-icon">${btn.icon}</div>
                    <div class="button-label">${btn.label}</div>
                `;

                button.addEventListener('click', () => sendAction(btn.action));
                deckElement.appendChild(button);
            });
        }

        // Discover server on local network
        async function discoverServer(skipLastHost = false) {
            // Try last known host from cookies first (unless explicitly skipped)
            if (!skipLastHost) {
                const lastHost = getCookie('webdeck_lasthost');
                if (lastHost) {
                    updateConnectionStatus('scanning', `Trying last known host: ${lastHost}...`);
                    if (await testConnection(`http://${lastHost}:8001`)) {
                        return `http://${lastHost}:8001`;
                    }
                    // Last known host is no longer active, clear it and prompt user
                    return null;
                }
            }

            // Always try localhost automatically
            updateConnectionStatus('scanning', 'Checking localhost...');
            const localhostAddress = 'http://localhost:8001';
            if (await testConnection(localhostAddress)) {
                setCookie('webdeck_lasthost', 'localhost');
                return localhostAddress;
            }

            return null;
        }

        // Scan network for server
        async function scanNetwork() {
            updateConnectionStatus('scanning', 'Scanning local network...');
            closeModal();

            try {
                // If localhost didn't work, try scanning common local IP ranges
                const addresses = generateLocalIPs();
                for (const address of addresses) {
                    updateConnectionStatus('scanning', `Trying ${address.split('://')[1]}...`);
                    if (await testConnection(address)) {
                        // Store the successful host in cookies
                        const host = address.split('://')[1].split(':')[0];
                        setCookie('webdeck_lasthost', host);
                        return address;
                    }
                }
            } catch (e) {
                // Continue with scanning
            }

            return null;
        }

        // Connect to user-provided IP
        async function connectToIP(ipAddress) {
            if (!ipAddress.trim()) {
                showStatus('Please enter an IP address');
                return;
            }

            const address = `http://${ipAddress.trim()}:8001`;
            updateConnectionStatus('scanning', `Trying ${ipAddress}...`);
            closeModal();

            if (await testConnection(address)) {
                // Store the successful host in cookies
                setCookie('webdeck_lasthost', ipAddress.trim());
                return address;
            }

            showStatus('Could not connect to that IP address');
            return null;
        }

        // Generate common local IP addresses to try
        function generateLocalIPs() {
            const addresses = [];
            // Common private IP ranges
            const ranges = [
                { start: [10, 0, 0], end: 254 }
            ];

            for (const range of ranges) {
                for (let i = 1; i <= Math.min(50, range.end); i++) {
                    const ip = [...range.start, i].join('.');
                    addresses.push(`http://${ip}:8001`);
                }
            }
            return addresses;
        }

        // Test connection to a server
        async function testConnection(address) {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 1500);

                const response = await fetch(`${address}/discover`, {
                    method: 'GET',
                    mode: 'cors',
                    signal: controller.signal
                });

                clearTimeout(timeoutId);

                if (response.ok) {
                    const data = await response.json();
                    console.log('Server found:', data);
                    return true;
                }
            } catch (error) {
                // Connection failed, continue scanning
            }
            return false;
        }

        // Update connection status banner
        function updateConnectionStatus(status, details) {
            bannerElement.className = `connection-banner ${status}`;
            detailsElement.textContent = details;
        }

        // Modal management
        const modal = document.getElementById('connectionModal');
        const securityWarningModal = document.getElementById('securityWarningModal');

        function showModal() {
            modal.classList.add('show');
            document.getElementById('serverIP').focus();
        }

        function closeModal() {
            modal.classList.remove('show');
        }

        function showSecurityWarning() {
            securityWarningModal.classList.add('show');
        }

        function closeSecurityWarning() {
            securityWarningModal.classList.remove('show');
        }

        // Handle modal button clicks
        document.getElementById('scanBtn').addEventListener('click', () => {
            closeModal();
            showSecurityWarning();
        });

        document.getElementById('connectBtn').addEventListener('click', async () => {
            const ipAddress = document.getElementById('serverIP').value;
            if (ipAddress.trim()) {
                const address = await connectToIP(ipAddress);
                if (address) {
                    await onServerConnected(address);
                } else {
                    updateConnectionStatus('disconnected', 'Connection failed - try again');
                    showModal();
                }
            } else {
                // If no IP entered, show security warning before scanning
                closeModal();
                showSecurityWarning();
            }
        });

        // Handle security warning modal buttons
        document.getElementById('confirmScanBtn').addEventListener('click', async () => {
            closeSecurityWarning();
            const address = await scanNetwork();
            if (address) {
                await onServerConnected(address);
            } else {
                updateConnectionStatus('disconnected', 'Server not found - try again');
                showModal();
            }
        });

        document.getElementById('cancelScanBtn').addEventListener('click', () => {
            closeSecurityWarning();
            showModal();
        });

        // Allow Enter key to submit in IP input
        document.getElementById('serverIP').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('connectBtn').click();
            }
        });

        // Handle successful connection
        async function onServerConnected(address) {
            serverAddress = address;
            const host = address.split('://')[1];
            updateConnectionStatus('connected', `Connected to ${host}`);
            deckElement.classList.remove('disabled');
            // Fetch buttons from server and start refresh
            await fetchButtonConfiguration();
            startButtonRefresh(10000); // Refresh every 10 seconds
            console.log('Server connected:', address);
        }

        // Send action to server
        async function sendAction(action) {
            if (!serverAddress) {
                showStatus('Not connected to server');
                return;
            }

            try {
                const response = await fetch(`${serverAddress}/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ action: action, path: buttons.find(b => b.action === action)?.path || '' }),
                });

                if (response.ok) {
                    showStatus(`Sent: ${action} ✓`);
                } else {
                    showStatus(`Error: ${response.status} ✗`);
                    // Connection lost, restart discovery
                    serverAddress = null;
                    stopButtonRefresh();
                    discoverAndConnect();
                }
            } catch (error) {
                showStatus('Connection lost ✗');
                serverAddress = null;
                stopButtonRefresh();
                discoverAndConnect();
            }
        }

        // Show status message
        function showStatus(message) {
            statusElement.textContent = message;
            statusElement.classList.add('active');

            setTimeout(() => {
                statusElement.classList.remove('active');
            }, 2000);
        }

        // Main discovery and connection flow
        async function discoverAndConnect() {
            const address = await discoverServer();
            if (address) {
                await onServerConnected(address);
            } else {
                // No last host or it's inactive, show modal to prompt user
                updateConnectionStatus('disconnected', 'Server not found');
                showModal();
            }
        }

        // Start discovery on page load
        window.addEventListener('load', () => {
            discoverAndConnect();
        });
    </script>
</body>
</html>
